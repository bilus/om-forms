;; Analyzed by ClojureScript 1.7.122
{:use-macros nil, :excludes #{}, :name reforms.table, :imports nil, :requires {impl reforms.core.impl, reforms.core.impl reforms.core.impl, binding reforms.binding.core, reforms.binding.core reforms.binding.core, set clojure.set, clojure.set clojure.set}, :uses nil, :defs {simple-checkbox {:protocol-inline nil, :meta {:file "/Users/martinb/dev/clojure_apps/reforms/om-reforms/../reforms/src/reforms/table.cljs", :line 9, :column 7, :end-line 9, :end-column 22, :arglists (quote ([checked & {:keys [on-click]}])), :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(checked {:keys [on-click]})], :arglists ([checked & {:keys [on-click]}]), :arglists-meta (nil)}}, :name reforms.table/simple-checkbox, :variadic true, :file "../reforms/src/reforms/table.cljs", :end-column 22, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(checked {:keys [on-click]})], :arglists ([checked & {:keys [on-click]}]), :arglists-meta (nil)}, :method-params [(checked {:keys [on-click]})], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 9, :end-line 9, :max-fixed-arity 1, :fn-var true, :arglists ([checked & {:keys [on-click]}])}, all-selected? {:protocol-inline nil, :meta {:file "/Users/martinb/dev/clojure_apps/reforms/om-reforms/../reforms/src/reforms/table.cljs", :line 15, :column 7, :end-line 15, :end-column 20, :arglists (quote ([selected-values all-values]))}, :name reforms.table/all-selected?, :variadic false, :file "../reforms/src/reforms/table.cljs", :end-column 20, :method-params ([selected-values all-values]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 15, :end-line 15, :max-fixed-arity 2, :fn-var true, :arglists (quote ([selected-values all-values]))}, table {:protocol-inline nil, :meta {:file "/Users/martinb/dev/clojure_apps/reforms/om-reforms/../reforms/src/reforms/table.cljs", :line 22, :column 7, :end-line 22, :end-column 12, :arglists (quote ([& args])), :doc "Renders a table of `rows` (col => value). An optional map of columns to labels can be specified which also\n   restricts which columns are visible.\n\n   Arguments:\n\n       [attrs] rows [options]\n\n       - attrs - (optional) attributes for <table> handed over to React (see https://github.com/r0man/sablono#html-attributes)\n       - rows - a vector of col->val maps\n       - options - (optional) options to customize the table\n\n   Options:\n\n       - :columns - map of keys used in `rows` to human-friendly column names\n       - :checkboxes - use this to support row selection using checkboxes, the map contains:\n           :selection - atom/cursor to keep selected rows in\n           :path - (optional) korks/path into the selection atom/cursor\n           :row-id - function applied to row map to calculate a unique row id to put into the selection set\n           :nil-selects-all? - (optional) selection set to nil (as opposed to #{}) selects all rows (default: false)\n         See the second example.\n\n   Example:\n\n        (table [{:name \"Tom\" :id 12} {:name \"Jerry\" :id 23}]\n               :columns {:name \"Hero name\"})\n\n   Result:\n  \n       | Hero name |\n       | Tom       |\n       | Jerry     |\n\n   As an option, each row can have an on/off checkbox to the left; to turn this on, `checkboxes` must be a map\n   with :cursor and :korks pointing to where to store the selection.  The resulting selection\n   is either a set containing values or nil; the latter means that all rows are selected.\n   The values are taken from the first val in the respective row or a result of :value function of\n   signature (fn [row]).\n\n   Example:\n\n       (table [{:name \"Tom\" :id 12} {:name \"Jerry\" :id 23}]\n              :checkboxes {:selection     app-state\n                           :path          [:selected-heroes]\n                           :row-id        :id}\n              :columns {:name \"Hero name\"})\n\n        | [ ] Hero name |\n        | [x] Tom       |\n        | [ ] Jerry     |\n\n       ;; For the above selection:\n       (get-in app-state [:selected-heroes]) => #{12}\n\n   Depending on the initial value of `app-state` in the above example the table start either\n\n   a) with all checkboxes on for `app-state` containing {:selected-heroes nil}, or\n   b) with no selection with {:selected-heroes #{}}.", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(args)], :arglists ([& args]), :arglists-meta (nil)}}, :name reforms.table/table, :variadic true, :file "../reforms/src/reforms/table.cljs", :end-column 12, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(args)], :arglists ([& args]), :arglists-meta (nil)}, :method-params [(args)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 22, :end-line 22, :max-fixed-arity 0, :fn-var true, :arglists ([& args]), :doc "Renders a table of `rows` (col => value). An optional map of columns to labels can be specified which also\n   restricts which columns are visible.\n\n   Arguments:\n\n       [attrs] rows [options]\n\n       - attrs - (optional) attributes for <table> handed over to React (see https://github.com/r0man/sablono#html-attributes)\n       - rows - a vector of col->val maps\n       - options - (optional) options to customize the table\n\n   Options:\n\n       - :columns - map of keys used in `rows` to human-friendly column names\n       - :checkboxes - use this to support row selection using checkboxes, the map contains:\n           :selection - atom/cursor to keep selected rows in\n           :path - (optional) korks/path into the selection atom/cursor\n           :row-id - function applied to row map to calculate a unique row id to put into the selection set\n           :nil-selects-all? - (optional) selection set to nil (as opposed to #{}) selects all rows (default: false)\n         See the second example.\n\n   Example:\n\n        (table [{:name \"Tom\" :id 12} {:name \"Jerry\" :id 23}]\n               :columns {:name \"Hero name\"})\n\n   Result:\n  \n       | Hero name |\n       | Tom       |\n       | Jerry     |\n\n   As an option, each row can have an on/off checkbox to the left; to turn this on, `checkboxes` must be a map\n   with :cursor and :korks pointing to where to store the selection.  The resulting selection\n   is either a set containing values or nil; the latter means that all rows are selected.\n   The values are taken from the first val in the respective row or a result of :value function of\n   signature (fn [row]).\n\n   Example:\n\n       (table [{:name \"Tom\" :id 12} {:name \"Jerry\" :id 23}]\n              :checkboxes {:selection     app-state\n                           :path          [:selected-heroes]\n                           :row-id        :id}\n              :columns {:name \"Hero name\"})\n\n        | [ ] Hero name |\n        | [x] Tom       |\n        | [ ] Jerry     |\n\n       ;; For the above selection:\n       (get-in app-state [:selected-heroes]) => #{12}\n\n   Depending on the initial value of `app-state` in the above example the table start either\n\n   a) with all checkboxes on for `app-state` containing {:selected-heroes nil}, or\n   b) with no selection with {:selected-heroes #{}}."}}, :require-macros nil, :cljs.analyzer/constants {:seen #{:thead :path :tbody :table :else :nil-selects-all? :columns :td :th :tr :xf :type :on-click :row-id :class :checked :input :onChange :selection :checkboxes}, :order [:on-click :input :onChange :checked :type :table :class :columns :checkboxes :xf :selection :path :row-id :nil-selects-all? :thead :tr :th :tbody :td :else]}, :doc nil}